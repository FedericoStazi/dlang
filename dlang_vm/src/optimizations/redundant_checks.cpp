// Copyright 2022 Federico Stazi. Subject to the MIT license.

#include "redundant_checks.h"

#include <unordered_map>

#include "../u_dlang/u_instruction.h"

void RemoveRedundantChecks::optimizeGraph(GraphPtr graph) {
  // The set of available expressions
  std::unordered_map<TNodePtr, ExprSet> avail;

  // Set all nodes to the universe set
  for (auto node : graph->getLine()) {
    avail[node] = ExprSet::makeUniverse();
  }

  // Create the avail sets of the nodes
  bool availHasChanged;
  do {
    availHasChanged = false;
    for (const auto& node : graph->getLine()) {
      auto availOld = avail[node];

      avail[node] = node->getPredecessors().empty() ? ExprSet::makeEmpty()
                                                    : ExprSet::makeUniverse();
      for (auto pred : node->getPredecessors()) {
        // Set of predecessors
        ExprSet predSet = avail[pred];

        // Killed by predecessor
        for (const auto& arg : pred->getValue()->getWriteArgs()) {
          predSet.erase(arg);
        }

        // Generated by predecessor
        if (auto check = pred->getValue()->getEffects().getTagCheck()) {
          predSet.insert(*check);
        }
        if (auto check = pred->getValue()->getEffects().getMemCheck()) {
          predSet.insert(check);
        }
        if (auto write = pred->getValue()->getEffects().getWrite()) {
          if (auto uSet = std::dynamic_pointer_cast<USet>(
              pred->getValue()->getUInstruction())) {
            if (auto uImm = std::dynamic_pointer_cast<UImmTag>(uSet->b)) {
              predSet.insert(*write, uImm->getValue());
            }
          }
        }

        // Intersect with other predecessors
        avail[node].intersect(predSet);
      }
      availHasChanged |= availOld != avail[node];
    }
  } while (availHasChanged);

  // Delete nodes whose effects are not needed
  for (auto node : graph->getLine()) {
    if (auto effect = node->getValue()->getEffects().getTagCheck()) {
      if (avail[node].get(*effect)) {
        removeNode(node);
      }
    }
    if (auto effect = node->getValue()->getEffects().getMemCheck()) {
      if (avail[node].get(effect)) {
        removeNode(node);
      }
    }
  }
}

RemoveRedundantChecks::ExprSet::ExprSet(bool conj) : conj_(conj) {}

RemoveRedundantChecks::ExprSet RemoveRedundantChecks::ExprSet::makeEmpty() {
  return ExprSet(false);
}
RemoveRedundantChecks::ExprSet RemoveRedundantChecks::ExprSet::makeUniverse() {
  return ExprSet(true);
}

void RemoveRedundantChecks::ExprSet::insert(const TEffects::Check& effect) {
  if (auto var = std::dynamic_pointer_cast<TVariable>(effect.first)) {
    insert(kNumTags_ * var->getUID() + static_cast<int>(effect.second.first));
  }
}

void RemoveRedundantChecks::ExprSet::insert(const TArgument::Ptr effect) {
  if (auto var = std::dynamic_pointer_cast<TVariable>(effect)) {
    insert(kNumTags_ * var->getUID() + kNumTags_ - 1);
  }
}

void RemoveRedundantChecks::ExprSet::insert(const TVariable& var, int tag) {
  insert(kNumTags_ * var.getUID() + tag);
}

void RemoveRedundantChecks::ExprSet::erase(TArgument::Ptr arg) {
  if (auto var = std::dynamic_pointer_cast<TVariable>(arg)) {
    for (int i = 0; i < kNumTags_; i++) {
      erase(kNumTags_ * var->getUID() + i);
    }
  }
}

bool RemoveRedundantChecks::ExprSet::get(const TEffects::Check& effect) {
  if (auto var = std::dynamic_pointer_cast<TVariable>(effect.first)) {
    return get(kNumTags_ * var->getUID()
               + static_cast<int>(effect.second.first));
  }
  return false;
}

bool RemoveRedundantChecks::ExprSet::get(TArgument::Ptr effect) {
  if (auto var = std::dynamic_pointer_cast<TVariable>(effect)) {
    return get(kNumTags_ * var->getUID() + kNumTags_ - 1);
  }
  return false;
}

void RemoveRedundantChecks::ExprSet::intersect(const ExprSet& other) {
  std::unordered_set<int> newVal;
  if (!conj_) {
    for (auto x : val_) {
      if (other.get(x)) {
        newVal.insert(x);
      }
    }
  } else {
    if (!other.conj_) {
      for (auto x : other.val_) {
        if (get(x)) {
          newVal.insert(x);
        }
      }
      conj_ = false;
    } else {
      for (auto x : val_) {
        newVal.insert(x);
      }
      for (auto x : other.val_) {
        newVal.insert(x);
      }
    }
  }
  val_ = newVal;
}

bool RemoveRedundantChecks::ExprSet::operator!=(const ExprSet& other) {
  return (conj_ != other.conj_) || (val_ != other.val_);
}

void RemoveRedundantChecks::ExprSet::insert(int x) {
  if (conj_) { val_.erase(x); } else { val_.insert(x); }
}

void RemoveRedundantChecks::ExprSet::erase(int x) {
  if (conj_) { val_.insert(x); } else { val_.erase(x); }
}

bool RemoveRedundantChecks::ExprSet::get(int x) const {
  return conj_ ? !val_.count(x) : val_.count(x);
}
